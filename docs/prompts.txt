Actions
- team_management
- billing

Conversations
- manager_report
- initial_check_in


- create conversation
- send initial messages

class MessagesController
  def create
    SendMessageWorker.perform_async(@conversation.id, params[:message], current_user.id)
    head :no_content
  end
end

class Message
  after_create :summarize_content
  after_create :deliver, unless -> { web_based && system? }

    def summarize_content
      SummarizeMessageWorker.perform_async(self.id)
    end

    def deliver
      case conversation.medium
        when :email
            # TODO: Send email
        when :web
          if user_id.present? # as system messages for web flow are streamed from SendMessageWorker
              ActionCable.server.broadcast "conversation_#{self.conversation_id}", {
                message: self.content,
                user_id: self.user_id,
                summary: self.summary
              }
          end
      end
    end

    def system?
      user_id.blank?
    end
end

class SendMessageWorker
  def perform(conversation_id, message, user_id)
    conversation = Conversation.find_by(id: conversation.id)
    return if conversation.blank?

    message = conversation.messages.create!(
      content: message,
      state: :sent,
      user: User.find_by(id: user_id)
    )

    SummarizeMessageWorker.perform_async(message.id)

    if message.user.present?
      response_prompt_code = Prompt.new(:fetch_relevant_response_prompt, input: { conversation: conversation, message: message.content }).execute

      if response_prompt_code.present?
        response = Prompt.new(response_prompt_code, input: { message: message.content }).execute
        SendMessageWorker.perform_async(conversation.id, response)
      end
    end
  end
end

class SummarizeMessageWorker
  include Sidekiq::Worker

  def perform(message_id)
    message = Message.find_by(id: message_id)
    summary = Prompt.new(:summarize, input: { message: message.content }).execute

    # TODO: Offload to S3 instead of storing giant blocks of text in Postgres
    message.update(summary: summary, state: :summarized)
  end
end

submissions = [
  "we missed our sprint goal again and no one seems to care",
  "the new hire is super sharp but struggling with our monolith",
  "CI is randomly failing tests that pass locally",
  "the team is shipping fast but morale feels low",
  "standups have become status theater and nobody is listening",
  "our cloud costs jumped 3x after a new deployment pipeline",
  "half our senior devs are burned out and taking time off",
  "prod broke again because someone bypassed the feature flag",
  "handoffs between frontend and backend keep dropping context",
  "our design system is slowing everyone down but no one owns it",
  "product keeps changing priorities mid-sprint",
  "infra team is fighting with app team over who owns what",
  "we onboarded 10 engineers and now everything feels chaotic",
  "retros are just venting sessions with no follow-through",
  "not sure what the problem is but things just feel off lately"
]

submissions.each_with_index do |input, i|
  puts "#{i + 1}. #{input}\n#{Prompt.new(:fetch_relevant_links, input: { incident: input }).execute}"
end